// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include "./cplexMOPoolSearch.hpp"
#include "./readParetoSets.hpp"
#include "./OptFrame/Loader.hpp"
#include "./OptFrame/RandGen.hpp"

using namespace std;
using namespace optframe;

vector<string> generateInstanceNames(string filename, vector<int> vNMilp, vector<int> vTlim)
{
	stringstream ss;
	vector<string> vInstances;

	//Temp vector discretization T for the instances of the UAV routing
//	vector<int> vTMax;

	for (int n = 0; n < vNMilp.size(); n++)
		for (int tLim = 0; tLim < vTlim.size(); tLim++)
		{
			ss << "./ResultadosFronteiras/" << filename << "NExec" << n << "TLim" << tLim; // << "-bestMIPStart";
			vInstances.push_back(ss.str());
		}

	return vInstances;
}
void fillVectorWithAllCombinations(vector<vector<double> >& values, vector<vector<double> >& combinations)
{
	vector<int> vIndex(values.size(), 0);
	bool exitWhile = true;
	do
	{
		int nObj = values.size();

		for (int i = 0; i < values[0].size(); i++)
		{
			vector<double> coef(nObj);
			for (int o = 0; o < nObj; o++)
				coef[o] = values[o][vIndex[o]];

			combinations.push_back(coef);
			vIndex[0]++;
		}
		vIndex[0] = 0;

//		cout << combinations << endl;
//		cout << index << endl;
//		getchar();

		for (int o = 1; o < nObj; o++)
		{

			if (vIndex[o] < (values[o].size() - 1))
			{
				vIndex[o]++;
				o = nObj;
				break;
			}
			else
			{
				vIndex[o] = 0;

				if (o == (nObj - 1))
					exitWhile = false;
			}
		}

	} while (exitWhile);

}

int main(int argc, char **argv)
{
	int nOfArguments = 5;

	if (argc != (1 + nOfArguments))
	{
		cout << "Parametros incorretos!" << endl;
		cout << "At least two parameters should be given : \n"
				"1 - instance \n"
				"3 - int - solver time limit \n"
				"2 - bool - Mip start (optional) - Default false \n"
				"4 - int - maxTriesForFirstFeasible (optional) - Default 1 \n"
				"5 - int NIntervals (optional) - Default 1 - other set values by hand at code \n" << endl;

		exit(1);
	}
	const char* instancia = argv[1];
	int tLim = atoi(argv[2]);
	bool mipStart = atoi(argv[3]);
	int argvMaxTries(atoi(argv[4]));
	int nIntervalsCoef = atoi(argv[5]);

	string filename = instancia;
	cout << "==============================================" << endl;
	cout << "filename = " << filename << endl;
	cout << "mipStart = " << mipStart << endl;
	cout << "tLim = " << tLim << endl;
	cout << "nIntervalsCoef(optinal) = " << nIntervalsCoef << endl;

	RandGenMersenneTwister rg;
	long seed = time(NULL);
	seed = 2;
	cout << "seed = " << seed << endl;
	srand(seed);
	rg.setSeed(seed);
	cout << "==============================================\n" << endl;

//	readParetoSets rPS;
//		rPS.exec(filename, mipStart, nIntervalsCoef, tLim);

	//	mModel.analyzeParetoFronts("./ResultadosFronteiras/ParetoFrontInputbWCMNExec27TLim10-bestMIPStart", 68, "./ResultadosFronteiras/ParetoFrontInputbWCMNExec27TLim10", 44);
	//	getchar();

	int nOptObj = 2;
	int nCriteria = 0;
	vector<double> referencePointsHV =
	{ 10000, 10000 };
	vector<double> utopicSol =
	{ -1000, 0};
	MOMETRICS<int> moMetrics(nOptObj);
//	SPOOLStruct spoolStruct(moMetrics, referencePointsHV, utopicSol);

	//Specific struct for Smart Storage Problems -- TODO -- Adapt for your problem your use default
	SPOOLStruct spoolStructSmartStorage(moMetrics, referencePointsHV, utopicSol);
	cplexMOPoolSearch mModel(rg, spoolStructSmartStorage);

	//================================
	//Generating objective functions weights with pre-defined vector of lambda values
	vector<vector<double> > vPossibleCoefs(nOptObj);
	/*vPossibleCoefs[0] =
	{	0, 0.5,1 };
	vPossibleCoefs[1] =
	{	0, 0.5,1 };*/
	vPossibleCoefs[0] =
		{	0, 0.2, 0.4, 0.6, 0.8 ,1 };
		vPossibleCoefs[1] =
		{	0, 0.2, 0.4, 0.6, 0.8 ,1 };

//	vPossibleCoefs[2] =
//	{	1, 10};
//	vPossibleCoefs[3] =
//	{	1};
//	vPossibleCoefs[4] =
//	{	0.01, 0.1};
//	vPossibleCoefs[5] =
//	{	1, 10};
//	vPossibleCoefs[6] =
//	{	1, 10};
//	vPossibleCoefs[0] =
//	{	1};
//	vPossibleCoefs[1] =
//	{	0.1};
//	vPossibleCoefs[2] =
//	{	1};
//	vPossibleCoefs[3] =
//	{	1};
//	vPossibleCoefs[4] =
//	{	0.01,};
//	vPossibleCoefs[5] =
//	{	1};
//	vPossibleCoefs[6] =
//	{	1};
	//================================

//	vector<double> referencePointsHV =
//	{ 100, 500, 30, 150, 1500, 30, 30 };
//	vector<double> utopicSol =
//	{ 0, 1, 1, 10, 0, 1, 2 };

//	readParetoSets rPS(nOptObj, moMetrics);
//	vector<string> vInstances =
//	{ "lowerLayerT6NExec64TLim10", "lowerLayerT6NExec64TLim20", "lowerLayerT6NExec64TLim30", "lowerLayerT6NExec64TLim40",
//			"lowerLayerT7NExec64TLim10", "lowerLayerT7NExec64TLim20", "lowerLayerT7NExec64TLim30", "lowerLayerT7NExec64TLim40",
//			"lowerLayerT10NExec64TLim20", "lowerLayerT10NExec64TLim30", "lowerLayerT10NExec64TLim40",
//			"lowerLayerT15NExec64TLim30", "lowerLayerT15NExec64TLim40" };
//	for (int i = 0; i < vInstances.size(); i++)
//	{
//		stringstream tempss;
//		tempss << "./ResultadosFronteirasGreen/" << vInstances[i];
//		vInstances[i] = tempss.str();
//	}
//	vInstances = generateInstanceNames();

//	rPS.exec(vInstances, utopicSol, referencePointsHV);
//	cout << "Read Pareto finished with sucess!" << endl;
//	getchar();

	vector<vector<double> > vMILPCoefs;
	fillVectorWithAllCombinations(vPossibleCoefs, vMILPCoefs);
	cout << "possible combination are:\n" << vMILPCoefs << endl;
	int maxTriesWithTLimUntilFirstFeasible = argvMaxTries; //max number of times it will optimize with tLim until finding the First Feasible
	maxTriesWithTLimUntilFirstFeasible = 30;

	vector<vector<double> > obtainedPFValues;
	obtainedPFValues = mModel.exec(filename, mipStart, vMILPCoefs, tLim, nOptObj, nCriteria, maxTriesWithTLimUntilFirstFeasible);


	cout<<obtainedPFValues<<endl;
//	 obj: + totalDist + timeToDeliver + nUsedDrones + dronesMaxSpeed
//	 + maximizeFinalCharge + makeSpanLC + makeSpanLD

//	double hv = moMetrics.hipervolumeWithExecRequested(obtainedPFValues, referencePointsHV, true);
//	double delta = moMetrics.deltaMetric(obtainedPFValues, utopicSol, true);
//	cout << "hv = " << hv << endl;
//	cout << "delta = " << delta << endl;

	cout << "Main finished com sucesso!" << endl;
}
