// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include "./cplexMOPoolSearch.hpp"
#include "./readParetoSets.hpp"
#include "./OptFrame/Loader.hpp"
#include "SPOOLStructSmartStorage.h"

using namespace std;
using namespace optframe;

vector<string> generateInstanceNames(string filename, vector<int> vNMilp, vector<int> vTlim)
{
	stringstream ss;
	vector<string> vInstances;

	//Temp vector discretization T for the instances of the UAV routing
//	vector<int> vTMax;

	for (int n = 0; n < vNMilp.size(); n++)
		for (int tLim = 0; tLim < vTlim.size(); tLim++)
		{
			ss << "./ResultadosFronteiras/" << filename << "NExec" << n << "TLim" << tLim; // << "-bestMIPStart";
			vInstances.push_back(ss.str());
		}

	return vInstances;
}
void fillVectorWithAllCombinations(vector<vector<double> >& values, vector<vector<double> >& combinations)
{
	vector<int> vIndex(values.size(), 0);
	bool exitWhile = true;
	do
	{
		int nObj = values.size();

		for (int i = 0; i < values[0].size(); i++)
		{
			vector<double> coef(nObj);
			for (int o = 0; o < nObj; o++)
				coef[o] = values[o][vIndex[o]];

			combinations.push_back(coef);
			vIndex[0]++;
		}
		vIndex[0] = 0;

//		cout << combinations << endl;
//		cout << index << endl;
//		getchar();

		for (int o = 1; o < nObj; o++)
		{

			if (vIndex[o] < (values[o].size() - 1))
			{
				vIndex[o]++;
				o = nObj;
				break;
			}
			else
			{
				vIndex[o] = 0;

				if (o == (nObj - 1))
					exitWhile = false;
			}
		}

	} while (exitWhile);

}

int mainComputeValuesAPEN_SI()
{

	int nOptObj = 3;

	MOMETRICS<int> moMetrics(nOptObj);

	readParetoSets rPS(nOptObj, moMetrics);

	string folderName = "ResultadosFronteiras/APEN_SI_OPTPLEX/";
	string instanceName = "ResidencialArea_A_20PEVs_50UAVs_120FHNExec27";
	string dc1 = "TLim10";
	string dc2 = "TLim30";
	string dc3 = "TLim60";

	vector<string> vInstances;
	int nBatches = 2;

	for (int r = 1; r <= nBatches; r++)
	{
		stringstream ssInstanceName;
		ssInstanceName << folderName << "R" << r << "/" << instanceName;
		//vInstances.push_back(ssInstanceName.str().c_str() + dc1);
		vInstances.push_back(ssInstanceName.str().c_str() + dc2);
		vInstances.push_back(ssInstanceName.str().c_str() + dc3);

	}

	string paretoOutput = folderName + instanceName;

//{ 100, 2000, 100 }; First MG
	vector<double> referencePointsHV =
	{ 10000, 2000, 500 };
	vector<double> utopicSol =
	{ -100, 0, 0 };

//	for (int i = 0; i < vInstances.size(); i++)
//	{
//		stringstream tempss;
//		tempss << "./ResultadosFronteiras/APEN_SI/" << vInstances[i];
//		vInstances[i] = tempss.str();
//	}
//	vInstances = generateInstanceNames();

	int nDiffConfigurations = vInstances.size() / nBatches;
	cout << "going to read " << nBatches << " batches with " << nDiffConfigurations << " configurations" << endl;
	rPS.execForBatches(vInstances, utopicSol, referencePointsHV, paretoOutput, nBatches, nDiffConfigurations);

	cout << "Compute values finished com sucesso!" << endl;
}

int main(int argc, char **argv)
{
	mainComputeValuesAPEN_SI();

	exit(1);
	int nOfArguments = 5;

	if (argc < (1 + nOfArguments))
	{
		cout << "Parametros incorretos!" << endl;
		cout << "At least two parameters should be given : \n"
				"1 - instance \n"
				"3 - int - solver time limit \n"
				"2 - bool - Mip start (optional) - Default false \n"
				"4 - int - maxTriesForFirstFeasible (optional) - Default 1 \n"
				"5 - int NIntervals (optional) - Default 1 - other set values by hand at code \n" << endl;

		exit(1);
	}
	const char* instancia = argv[1];
	int tLim = atoi(argv[2]);
	bool mipStart = atoi(argv[3]);
	//max number of times it will optimize with tLim until finding the First Feasible
	int argvMaxTriesWithTLimUntilFirstFeasible(atoi(argv[4]));
	argvMaxTriesWithTLimUntilFirstFeasible = 100; //todo forcing value
	int nIntervalsCoef = atoi(argv[5]);

	string filename = instancia;
	cout << "==============================================" << endl;
	cout << "filename = " << filename << endl;
	cout << "mipStart = " << mipStart << endl;
	cout << "tLim = " << tLim << endl;
	cout << "nIntervalsCoef(optinal) = " << nIntervalsCoef << endl;

	RandGenMersenneTwister rg;
	long seed = time(NULL);
	seed = 2;
	cout << "seed = " << seed << endl;
	srand(seed);
	rg.setSeed(seed);
	cout << "==============================================\n" << endl;

	//	readParetoSets rPS;
	//	rPS.exec(filename, mipStart, nIntervalsCoef, tLim);

	//	mModel.analyzeParetoFronts("./ResultadosFronteiras/ParetoFrontInputbWCMNExec27TLim10-bestMIPStart", 68, "./ResultadosFronteiras/ParetoFrontInputbWCMNExec27TLim10", 44);
	//	getchar();

	int nOptObj = 3;
	int nCriteria = 0;
	vector<double> referencePointsHV =
	{ 10000, 10000, 10000 };
	vector<double> utopicSol =
	{ -1000, 0, 0 };
	MOMETRICS<int> moMetrics(nOptObj);
//	SPOOLStruct spoolStruct(moMetrics, referencePointsHV, utopicSol);

	//Specific struct for Smart Storage Problems -- TODO -- Adapt for your problem your use default
	SPOOLStructSmartStorage spoolStructSmartStorage(moMetrics, referencePointsHV, utopicSol);
	cplexMOPoolSearch mModel(rg, spoolStructSmartStorage);

	//================================
	//Generating objective functions weights with pre-defined vector of lambda values
	vector<vector<double> > vPossibleCoefs(nOptObj);
//	vPossibleCoefs[0] =
//	{	0, 0.5, 1};
//	vPossibleCoefs[1] =
//	{	0, 0.1,1};
//	vPossibleCoefs[2] =
//	{	0.0001, 0.1, 10};
	vPossibleCoefs[0] =
	{	0.5};
	vPossibleCoefs[1] =
	{	1, 0.1};
	vPossibleCoefs[2] =
	{	0.0001};
	vector<vector<double> > vMILPCoefs;
	fillVectorWithAllCombinations(vPossibleCoefs, vMILPCoefs);
	cout << "possible combination are:\n" << vMILPCoefs << endl;
//	getchar();
	//================================

	readParetoSets rPS(nOptObj, moMetrics);
//	vector<string> vInstances =
//	{ "lowerLayerT6NExec64TLim10", "lowerLayerT6NExec64TLim20", "lowerLayerT6NExec64TLim30", "lowerLayerT6NExec64TLim40",
//			"lowerLayerT7NExec64TLim10", "lowerLayerT7NExec64TLim20", "lowerLayerT7NExec64TLim30", "lowerLayerT7NExec64TLim40",
//			"lowerLayerT10NExec64TLim20", "lowerLayerT10NExec64TLim30", "lowerLayerT10NExec64TLim40",
//			"lowerLayerT15NExec64TLim30", "lowerLayerT15NExec64TLim40" };

//	vector<string> vInstances =
//	{
//	"REED_1House_1PEVs_3UAVs_120FH",
//	"REED_1House_1PEVs_5UAVs_120FH",
//	"REED_1House_2PEVs_3UAVs_120FH",
//	"REED_1House_2PEVs_5UAVs_120FH",
//	"ResidencialArea_A_20PEVs_20UAVs_120FH",
//	"ResidencialArea_A_20PEVs_50UAVs_120FH",
//	"ResidencialArea_A_5PEVs_20UAVs_120FH",
//	"ResidencialArea_A_5PEVs_50UAVs_120FH"};

//	vector<string> vInstances =
//	{
//	"REED_1House_1PEVs_3UAVs_120FH",
//	"REED_1House_1PEVs_5UAVs_120FH",
//	"REED_1House_2PEVs_3UAVs_120FH",
//	"REED_1House_2PEVs_5UAVs_120FH",
//	"ResidencialArea_A_20PEVs_20UAVs_120FH",
//	"ResidencialArea_A_20PEVs_50UAVs_120FH",
//	"ResidencialArea_A_5PEVs_20UAVs_120FH",
//	"ResidencialArea_A_5PEVs_50UAVs_120FH"};
//
//
//	for (int i = 0; i < vInstances.size(); i++)
//	{
//		stringstream tempss;
//		tempss << "./ResultadosFronteiras/APEN_SI/" << vInstances[i];
//		vInstances[i] = tempss.str();
//	}
//	vInstances = generateInstanceNames();

//	rPS.exec(vInstances, utopicSol, referencePointsHV);
//	cout << "Read Pareto finished with sucess!" << endl;
//	getchar();

	vector<vector<double> > obtainedPFValues;
	obtainedPFValues = mModel.exec(filename, mipStart, vMILPCoefs, tLim, nOptObj, nCriteria, argvMaxTriesWithTLimUntilFirstFeasible);

	//CORS - UAV Routing OBJ
//	 obj: + totalDist + timeToDeliver + nUsedDrones + dronesMaxSpeed
//	 + maximizeFinalCharge + makeSpanLC + makeSpanLD

	double hv = moMetrics.hipervolumeWithExecRequested(obtainedPFValues, referencePointsHV, true);
	double delta = moMetrics.deltaMetric(obtainedPFValues, utopicSol, true);
	cout << "hv = " << hv << endl;
	cout << "delta = " << delta << endl;

	cout << "Main finished com sucesso!" << endl;
}
